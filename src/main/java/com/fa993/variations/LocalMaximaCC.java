package com.fa993.variations;

import com.fa993.types.LocalMaximaOutput;

import java.util.ArrayList;
import java.util.List;

/**
 * Implementation of the {@link LocalMaxima} interface using a direct translation
 * of the numpy-based algorithm for finding local maxima in a 1D signal.
 *
 * Generated By CodeConvert
 *
 * This implementation determines the indices of local maxima along with the left
 * and right edges of each peak in the input array.
 *
 * @see <a href="https://github.com/scipy/scipy/blob/92d2a8592782ee19a1161d0bf3fc2241ba78bb63/scipy/signal/_peak_finding_utils.pyx#L20C1-L21C1">
 *      LocalMaxima source</a>
 */
public class LocalMaximaCC implements LocalMaxima {

	/**
	 * Detects local maxima in a 1D signal.
	 *
	 * This method iterates through the input array to identify points where the
	 * signal value at a specific index is greater than its neighbors, thereby
	 * identifying local maxima. The midpoints, left edges, and right edges of
	 * each peak are computed and returned.
	 *
	 * @param x The input signal array.
	 * @return A {@link LocalMaximaOutput} object containing:
	 *         - `midpoints`: The indices of the midpoints of the detected peaks.
	 *         - `leftEdges`: The indices of the left edges of each peak.
	 *         - `rightEdges`: The indices of the right edges of each peak.
	 * @throws IllegalArgumentException If the input array is null.
	 */
	public LocalMaximaOutput localMaxima1D(double[] x) {
		if (x == null) {
			throw new IllegalArgumentException("Input array cannot be null");
		}

		int n = x.length;
		List<Integer> midpoints = new ArrayList<>();
		List<Integer> leftEdges = new ArrayList<>();
		List<Integer> rightEdges = new ArrayList<>();

		int m = 0; // Pointer to the end of valid area in allocated arrays

		int i = 1; // Pointer to current sample, first one can't be maxima
		int iMax = n - 1; // Last sample can't be maxima
		while (i < iMax) {
			// Test if previous sample is smaller
			if (x[i - 1] < x[i]) {
				int iAhead = i + 1; // Index to look ahead of current sample

				// Find next sample that is unequal to x[i]
				while (iAhead < iMax && x[iAhead] == x[i]) {
					iAhead++;
				}

				// Maxima is found if next unequal sample is smaller than x[i]
				if (iAhead < n && x[iAhead] < x[i]) {
					leftEdges.add(i);
					rightEdges.add(iAhead - 1);
					midpoints.add((leftEdges.get(m) + rightEdges.get(m)) / 2);
					m++;
					// Skip samples that can't be maximum
					i = iAhead;
				}
			}
			i++;
		}

		// Convert lists to arrays
		return new LocalMaximaOutput(midpoints.stream().mapToInt(t -> t).toArray(),
				leftEdges.stream().mapToInt(t -> t).toArray(),
				rightEdges.stream().mapToInt(t -> t).toArray());
	}
}

